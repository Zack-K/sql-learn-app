# 基本設計書 (Design Document)

## 1. システム構成
- バックエンド（サーバー）とフロントエンドを持つクライアント・サーバー構成。
- クライアント側は HTMX を利用し、JavaScriptの記述を最小化しながら非同期（SPA風）の快適な動作を実現する。
- データの永続化はサーバー側のデータベース（SQLite等）で行う。

## 2. 技術スタック案
- **バックエンド:** Python (FastAPI または Flask)
- **データベース:** SQLite (環境構築が不要なファイルベースDB)
- **フロントエンド:** HTML / Vanilla CSS / HTMX (HATEOASアプローチ)

## 3. 画面定義・レイアウト
- **全体レイアウト:**
  - 画面全体をダークテーマ（ダークグレー背景＋白字基調）とする。
  - 左側に「ナビゲーション＆問題文ペイン」、右側に「エディタ＆解答ペイン」を配置する2カラム構成。
- **左ペイン:**
  - Day 1 〜 Day 17 までのナビゲーション。
  - 選択中のDayの「学習目標」「課題文」。
- **右ペイン:**
  - **SQL Playground (上部):【NEW】**
    - 各Dayに専用のダミーデータテーブルが用意されており、ユーザーが実際のSQL（例: `SELECT * FROM orders`）を叩いて結果をHTMLの表形式（Table）でプレビューできる領域。
  - **SOL 回答エリア (下部):**
    - 問題の解法（アルゴリズム）となるSOLを記述するためのテキストエリア。
  - **アクション:** 「解答例を見る」ボタン、「保存する」ボタン。
  - **解答表示エリア:** ボタン押下後にトグルで展開される、模範解答・解説。

## 4. SQL Playground アーキテクチャ (シニアエンジニア設計)
ユーザーが入力した任意のSQLを安全かつ副作用なく実行するため、以下のアーキテクチャを採用する。
1. **In-Memory Database (`sqlite:///:memory:`) の活用**
    - SQL実行リクエストが来るたびに、動的にオンメモリでSQLiteデータベースを生成する。
    - ドリルデータ（JSON）に定義された `mock_data` を元に一時テーブルを作成・データ投入する。
    - ユーザーのSQLを実行し、結果セット（Column名とRowの配列）を返し、インメモリDBは破棄する（状態を持たない完全なサンドボックス実行）。
2. **HTMXによる非同期レンダリング**
    - 実行ボタン押下時にHTMXでバックエンドの `/run_sql` にPOSTし、結果のHTML `<table>` フラグメントだけを取得して画面を更新する。

## 5. データ構造定義 (ドリルデータ)
17日分の課題は、静的なデータオブジェクト（JSONまたはJS変数）として持たせる。
```json
{
  "day": 1,
  "title": "SOLで「手続き」を書く",
  "goal": "自然言語で書かれた手順をSOL風の手続きに落とす。",
  "schema": [
    {
       "table_name": "users_csv",
       "columns": ["id", "name", "email"],
       "mock_data": [
         {"id": 1, "name": "Alice", "email": "alice@example.com"},
         {"id": 2, "name": "Bob", "email": "bob@example.com"}
       ]
    }
  ],
  "question": "CSVファイルを読み込み、ヘッダーをスキップして各行を1件ずつ処理する手順をSOLで書いてください。",
  "example_answer": "function process_users_csv(filepath) {\n    ...\n}",
  "explanation": "解説文：ETLでは..."
}
```
